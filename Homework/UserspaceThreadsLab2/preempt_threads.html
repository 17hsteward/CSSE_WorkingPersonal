<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Userspace Threads</title>
<!-- 2018-03-13 Tue 21:06 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Buffalo" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Userspace Threads</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Introduction</a>
<ul>
<li><a href="#sec-1-1">1.1. How</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Read this</a></li>
<li><a href="#sec-3">3. An Example</a></li>
<li><a href="#sec-4">4. Moving from Basic to Preempt</a></li>
<li><a href="#sec-5">5. What to do</a>
<ul>
<li><a href="#sec-5-1">5.1. Standalone 1: The Basics</a></li>
<li><a href="#sec-5-2">5.2. Standalone 1: Problems</a></li>
<li><a href="#sec-5-3">5.3. Standalone 1: Segmentation Faults Solution</a></li>
<li><a href="#sec-5-4">5.4. Standalone 1: What's the deal with the lockup?</a></li>
<li><a href="#sec-5-5">5.5. Standalone 1: Weird printing</a></li>
<li><a href="#sec-5-6">5.6. Standalone 2: Yields, Creates, &amp; Finishes</a></li>
<li><a href="#sec-5-7">5.7. Test cases</a></li>
</ul>
</li>
<li><a href="#sec-6">6. Conclusion</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
In the last lab assignment we built a userspace threading system, but it
required the programmer to manually yield.  In some cases, this might
be OK - in particular it lets us ensure that a thread always gives up
control at some sensible time, but it does require more work for the
programmer using the thread system.  Also, it makes our system
vulnerable to one particular thread grabbing control and refusing to
yield (either because of a bug like an infinite loop, or because it
makes some sort of library function call that just takes a really long
time to run): this kind of thing breaks the illusion of multiple
threads running in parallel.
</p>

<p>
So in this assignment, we'll make our system preemptive.  That is,
we'll force our threads to give up control even if they don't yield.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> How</h3>
<div class="outline-text-3" id="text-1-1">
<p>
To have preemption we need a special facility: a way to force a
currently running thread off the CPU and run some other code (that we
will write to cause a thread switch).  Without this feature,
preemption is impossible.
</p>

<p>
In an OS, this is handled using interrupts (in particular, timer
interrupts), which are directly supported by your CPU.  That's great
for an OS, but we can't install interrupt handlers in non-kernel code.
So the OS must provide this facility to userspace processes if it's
going to exist.  
</p>

<p>
In LINUX, we can use signals.  Signals are normally used to catch
unexpected behaviors in code (e.g. user presses Control-C, some
arithmetic operation divides by zero).  These things would normally
crash our programs altogether, but we can install handlers that
trigger when these behaviors occur.  When a signal happens, our normal
code is suspended and the signal handler runs (one might think of it
as an involuntary function call).  That's the feature we want -
running arbitrary code without the say-so of the currently running
function.
</p>

<p>
There is a special alarm signal SIGALRM that we can use to signal
after a specific amount of time.  In our case, we'll cause a SIGALRM
to yield to the scheduler allowing other code to run.  But as usual
there will be complications..
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Read this</h2>
<div class="outline-text-2" id="text-2">
<p>
This code will require an understanding of signals and signal masks.
Read this:
</p>

<p>
[<a href="sigintro.html">sigintro.html</a>]
</p>

<p>
This was originally from <a href="http://titania.ctie.monash.edu.au/signals/">http://titania.ctie.monash.edu.au/signals/</a>
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> An Example</h2>
<div class="outline-text-2" id="text-3">
<p>
To compile and run this code, use gcc
</p>

<pre class="example">
gcc preempt_example.c -o preempt_example
./preempt_example
</pre>

<p>
You should see the parent and the child switch between each other,
even without a yield in the child code.
</p>

<p>
You'll want to understand this code completely before continuing on.
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Moving from Basic to Preempt</h2>
<div class="outline-text-2" id="text-4">
<p>
You will start from your code for the basic threads assignment; 
all the threading functions will be the same.  The only difference
will be a new version of schedule_threads
</p>

<pre class="example">
void schedule_threads_with_preempt(int usecs);
</pre>

<p>
When threads are scheduled with this function they will be preempted
every usecs microseconds (if they don't yield or finish naturally).
</p>

<p>
To begin:
</p>

<p>
Take your solution to the previous lab assignment and
</p>

<ol class="org-ol">
<li>Copy basic_threads.c to the directory containing the initial code
</li>
</ol>
<p>
for this assignment.
</p>
<ol class="org-ol">
<li>Rename it to preempt_threads.c
</li>
<li>Change it to include preempt_threads.h rather than basic_threads.h
</li>
<li>Modify schedule_threads to match the new signature
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> What to do</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Standalone 1: The Basics</h3>
<div class="outline-text-3" id="text-5-1">
<p>
We'll start with a straightforward application rather than a test.
Take a look at what the code does.
</p>

<p>
You should be able to compile it like this:
</p>

<pre class="example">
gcc standalone1.c preempt_threads.c -o standalone1
</pre>

<p>
If you run it without modifying schedule_threads, you should see
function 1 run and finish, then function 2 should start and finish.
This is the expected behavior because there are no yields.
</p>

<p>
Using the preempt example as a starting point, modify the code in
preempt_threads.c to use sigalrm to call yield.  If you do it correctly you
should see the 111/222 working calls interleave.
</p>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Standalone 1: Problems</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Adjust the wait time of standalone1 to something low (e.g. 5 usecs
although different systems may require tweaking) and then run it a
bunch of times.
</p>

<p>
You may see one of a couple problems, though it won't be consistent:
</p>

<ol class="org-ol">
<li>Segmentation faults
</li>
<li>Program freezes
</li>
<li>The "done" for each thread printing more than once
</li>
</ol>

<p>
These issues are caused by 3 unique problems.  Let's look at the first
one first.  This is caused by the alarm signal firing at inopportune
times.  Either:
</p>

<ol class="org-ol">
<li>When executing a swapcontext function
</li>
<li>In the parent thread, which shouldn't expect sudden yields and so
tends to have odd behavior
</li>
</ol>

<p>
While setting the wait time low exacerbates these problems, there's
nothing preventing this from happening with long waits except the fact
that switches are less frequent, so the errors are harder to find.
</p>

<p>
So we need to fix this.
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Standalone 1: Segmentation Faults Solution</h3>
<div class="outline-text-3" id="text-5-3">
<p>
We need to disable (i.e. mask) the alarm signal from occurring when it
is unsafe.  To do that, we'll use code like this&#x2026;see the appropriate
man pages for details:
</p>

<div class="org-src-container">

<pre class="src src-C">sigset_t mask;
sigemptyset (&amp;mask);
sigaddset (&amp;mask, SIGALRM);
if(sigprocmask(SIG_BLOCK, &amp;mask, NULL) &lt; 0) {
    perror ("sigprocmask");
}
</pre>
</div>

<p>
You may want to put this in a function.
</p>

<p>
Similarly, we need to re-enable the alarm when it is safe.  You should
write the appropriate code for that.
</p>

<p>
Whenever you're dealing with preemption issues, you should try to
codify the rules carefully and make sure you haven't missed any edge
cases.  Here are the rules to use:
</p>

<ol class="org-ol">
<li>Alarm signals should be masked when in the scheduler.  This way you
never have to deal with exciting edges cases involving the
scheduler yielding to itself.
</li>
<li>Alarm signals should be masked when adjusting shared thread
structures (e.g. the threads array, the datastructure that keeps 
track of which threads are valid, the currently running thread, etc.). 
Preemption at these times usually carries the risk of putting these 
structures in an inconsistent state.
</li>
<li>Alarm signals should be masked before switching contexts
(e.g. swapcontext).  An alarm preempting this code while
in-progress usually causes all sorts of exciting seg-faults.
</li>
<li>One minor non-obvious wrinkle: when you create a thread context
object, you probably want alarms to be masked.  This is true even
if you know the creation can't be preempted because you haven't
started the alarm signal for example.  The reason for this is a new
context has a different masking state from its parent, but it's
initialized to the same state as the parent.  But if you switch to
a context that does not have alarms masked, the switch can be
preempted in-progress (after we've switched to the new masking
state, but before the switch fully completes).  So by always
creating threads in a masked state, we ensure that newly created
threads finish starting before alarms can happen.  Of course, we
must then unmask before actually running the thread function.
</li>
<li>Alarm signals should NOT be masked when running ordinary code in
the threads.
</li>
<li>You should NOT mask/unmask alarms in your alarm signal handler.
This may seem non-obvious because of #2 &amp; #3.

<p>
The reason is twofold: 
</p>

<p>
a. A signal handler automatically masks signal of it's own type.
So there is no need to mask alarms in the alarm signal handler.
However, if you then unmask alarms in the signal handler, you'll
override this default behavior which is not desirable.
b. Adjusting alarms mask in a signal handler changes the behavior
of the signal handler, but not the code returned to after the
signal handler.  So unmasking alarms in the signal handler will not
mean alarms are unmasked in the code returned to.  Luckily, that
code keeps its mask from before the handler was called, which is
that alarms are unmasked.
</p>
</li>
<li>At the end of schedule_threads_with_preempt, you should reenable
alarm signals.  But before you do this, ensure that you don't
accidentally call your alarm handler because of a pending alarm.
Doing this will deregister your alarm handler:

<pre class="example">
signal(SIGALRM, SIG_IGN);
</pre>
</li>
</ol>

<p>
Modify your code to abide by these rules and you should see the
signals in Standalone 1 go away.
</p>
</div>
</div>


<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> Standalone 1: What's the deal with the lockup?</h3>
<div class="outline-text-3" id="text-5-4">
<p>
If you notice a lockup (i.e. program stops outputting and never
finishes) that's happening rarely, try removing all prints from your
scheduler (and alarm handler) and see if it goes away.  Turns out
there's an internal "lock" that functions like printf acquire before
they can write to the console.  This is surely designed for
multithreaded code - that is, to prevent weirdness when multiple
threads print at once.  Before the printf happens, the function
"acquires" the I/O lock.  While it's acquired, if any other thread
tries to print, it has to wait for the first thread to release the lock.
Under normal circumstances the first thread would finish printing and
"free" the lock.
</p>

<p>
If it surprises you that something designed to prevent threading
issues actually causes a seemingly major problem, don't be.  That is
usual, which is why most programmers are very paranoid about using
things like locks without being sure they don't have dangerous edge
cases.
</p>

<p>
So how does this cause your program to lockup?
</p>

<ol class="org-ol">
<li>One of the threads acquires the lock and prints
</li>
<li>Then the alarm goes off, dropping into the handler which switches
the context to the scheduler
</li>
<li>The scheduler tries to print a status message, but before the
message can be printed it must first acquire the lock.  So it
waits.
</li>
<li>Unfortunately because it is waiting, it can't actually switch to
another thread, meaning that thread from #1 will never run again.
The lock can never be freed.
</li>
</ol>
</div>

<ol class="org-ol"><li><a id="sec-5-4-0-1" name="sec-5-4-0-1"></a>Ok, how can we solve this?<br  /><div class="outline-text-5" id="text-5-4-0-1">
<p>
There are a couple solutions, none of them super satisfactory:
</p>

<ol class="org-ol">
<li>Have all thread code mask alarms before every print, then reenable
it afterword
</li>
<li>Write your own version of printf that does #1, and then make your
call to that version of printf rather than the regular one (this is
moderately annoying to do with a function like printf that takes a
variable number of arguments)
</li>
<li>Never do any printing in your scheduler
</li>
</ol>

<p>
Of these, #3 is probably what I would do.  But this won't turn out to
matter because of a completely different issue (Weird Printing,
below).
</p>
</div>
</li>

<li><a id="sec-5-4-0-2" name="sec-5-4-0-2"></a>I have a problem with lockups but not the one mentioned here<br  /><div class="outline-text-5" id="text-5-4-0-2">
<p>
That probably indicates a bug in your threading code.  You should fix
that.  I recommend using GDB to figure out where things are stuck.
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> Standalone 1: Weird printing</h3>
<div class="outline-text-3" id="text-5-5">
<p>
This is caused by a major limitation in our threading system.
</p>

<p>
So the userspace threading library we implemented before is actually a
relatively realistic example. Using SIGALRM to do preemption is not ideal,
really, because of something called async-signal-safety.
</p>

<p>
For a variety of reasons, it's often not safe to call a particular
function (say printf) while it is already running. For example, printf
uses some static data so if an in-progress call to printf is preempted,
and then the preempting code calls printf itself, this overwrites the
static data.  So when we return to the original call to printf, it
behaves strangely. ("strangely" sounds pretty benign, but bear in mind
this could just as easily segmentation fault or erase files on your
harddrive)
</p>

<p>
This is usually only a problem in signal handlers, which can preempt
arbitrary code and run at unexpected times.  For these handlers, there
is a list of functions that are considered "async-signal-safe"
(i.e. they can be called in a signal handler because even if they are
already running, they can be called again).  The list is here
<a href="https://docs.oracle.com/cd/E19455-01/806-5257/gen-26/index.html">https://docs.oracle.com/cd/E19455-01/806-5257/gen-26/index.html</a> but
the important thing to know about it is that this is a short list of
functions.  Normally, folks recommend you do as little as possible in
signal handlers, basically set a global that other parts of your
program read and process.
</p>

<p>
In our signal handlers though, we actually switch the thread and then
run it.  Meaning any function in our thread might be preempted, and
then that same function might well run in a different thread.  So we
are limited to only asyc-signal-safe functions in our threads (or, if
we wanted to we could turn off preemption before we call unsafe
functions).  This would probably not be a realistic requirement for a
LINUX threading system.
</p>

<p>
For our purposes though, it will be perfectly fine except we'll need
to use the async safe function write, rather than printf (or if you do
use printf for debugging or something, realize it may have occasional
problems).
</p>

<p>
Here's what using write to print looks like (note you must specify the
size of the string you're writing):
</p>

<pre class="example">
write(STDOUT_FILENO, "222 working\n",12); 
</pre>

<p>
If you switch your printf calls to use write, this problem should go
away (also the locking problem, because async-signal-safety pretty
much requires you don't acquire locks).  Although if you look at the
man page for write, you'll realize that for 100% correctness, you really
should be checking the return of write and depending on that, maybe 
re-run it. We won't require that, but just realize that making code 
correctly async-signal-safe is a tricky business.
</p>
</div>
</div>

<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> Standalone 2: Yields, Creates, &amp; Finishes</h3>
<div class="outline-text-3" id="text-5-6">
<p>
The second standalone application has threads that call create_new_thread, 
yield, and finish_thread.  In theory, if your solution works perfectly for 
Standalone 1, these should all continue to work.  In practice, you may
discover some bugs.
</p>

<p>
Note that this code uses write to do all it's printing (for the
reasons discussed above).  Be aware that you should not mix write and
printfs for debugging, because they will not print chronologically
(i.e. some printfs will print after some writes, even though the call
to printf occured before the writes).
</p>
</div>
</div>

<div id="outline-container-sec-5-7" class="outline-3">
<h3 id="sec-5-7"><span class="section-number-3">5.7</span> Test cases</h3>
<div class="outline-text-3" id="text-5-7">
<p>
To compile the test cases
</p>

<pre class="example">
gcc preempt_tests.c preempt_threads.c CuTest.c -o preempt_tests
</pre>

<p>
If your standalone #1 and #2 work, there shouldn't be much you need to
do to get the test cases to pass.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Conclusion</h2>
<div class="outline-text-2" id="text-6">
<p>
Submit your assignment in the usual way.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Buffalo</p>
<p class="date">Created: 2018-03-13 Tue 21:06</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
