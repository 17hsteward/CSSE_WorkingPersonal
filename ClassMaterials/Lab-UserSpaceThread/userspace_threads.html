<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Userspace Threads</title>
<!-- 2018-03-06 Tue 11:08 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Buffalo" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Userspace Threads</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Introduction</a>
<ul>
<li><a href="#sec-1-1">1.1. The Idea</a></li>
<li><a href="#sec-1-2">1.2. Why would we want this?</a></li>
</ul>
</li>
<li><a href="#sec-2">2. How</a></li>
<li><a href="#sec-3">3. An Example</a></li>
<li><a href="#sec-4">4. What we want</a></li>
<li><a href="#sec-5">5. Compiling and running tests</a></li>
<li><a href="#sec-6">6. What to do</a>
<ul>
<li><a href="#sec-6-1">6.1. Test 1: Just one thread</a></li>
<li><a href="#sec-6-2">6.2. Test 2: A Bunch of Threads</a></li>
<li><a href="#sec-6-3">6.3. Test 3: Reclaiming finished threads's slots</a></li>
<li><a href="#sec-6-4">6.4. Test 4: Thread parameters</a>
<ul>
<li><a href="#sec-6-4-1">6.4.1. Parameters?</a></li>
<li><a href="#sec-6-4-2">6.4.2. How to do this</a></li>
</ul>
</li>
<li><a href="#sec-6-5">6.5. Test 5: Removing the need for finish_thread</a></li>
<li><a href="#sec-6-6">6.6. Test 6: Freeing what we have malloced</a>
<ul>
<li><a href="#sec-6-6-1">6.6.1. Why it's a terrible idea</a></li>
<li><a href="#sec-6-6-2">6.6.2. How to fix it</a></li>
<li><a href="#sec-6-6-3">6.6.3. Testing this</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-7">7. Conclusion</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Let's say that you would like to write a multi-threaded application,
but your operating system doesn't support threads (i.e. it just runs
whole processes, which can't have sub-parts that are scheduled
separately).  Are you doomed to a single threaded program - no!  You
can implement your own user-space (as opposed to kernel-space)
threads.  The process you'll use is very similar to the way the OS
itself handles threads.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> The Idea</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Recall that what program is currently running in the CPU is entirely
determined by a few CPU registers (program counter, current stack
pointer, and a few others).  We usually adjust these registers, saving
and restoring their state, to allow things like function calls to
happen.  That's not the only way we can use them though!  We can also
save them, then switch them for entirely different values -
essentially switching our program into a whole new state with a whole
new stack.  Then at some later time, we can restore the old values and
from our code's perspective it will seem like they never left.  If we
switch between these two codebases fast enough, the two <b>threads</b> of
execution will appear to be running simultaneously.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Why would we want this?</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Although the threads will appear to be happening simultaneously,
actually they are only running one at a time on one CPU.  Given that,
we won't get any performance increase by using our threads to solve an
algorithm in parallel.  But there are many more uses for threads than
just writing parallel algorithms.
</p>

<p>
The most common use is event-based programming.  Imagine you want some
code to run when the mouse is clicked, while at the same time doing
some tricky calculation.  Without threads, your calculation code is
going to polluted in various places by checking the mouse.  Or imagine
data is periodically coming in from some source (say a network
download) and the same time other aspects of your program in running.
You want the download data to written to a file (say) but that's not
something the rest of you application should be constantly checking
and doing.  Even if the OS doesn't support threads, with userspace
threads we can easily handle all of this.
</p>

<p>
Another benefit is userspace threads tend to be quite a bit more
lightweight than kernel managed threads.  So if you want to write code
with a LOT of parallelism, usually using a kernel thread for each one
uses too much memory and is too slow.  The parallel languages Erlang
and Elixir for example, make use of a mix of userspace and kernel
threads to allow the creation of way more threads than could normally
be supported.  Using userspace threads also gives you complete control
over scheduling the threads, which means you can implement
optimization that the OS can't know about.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> How</h2>
<div class="outline-text-2" id="text-2">
<p>
So what we need to start with is a way to save the current execution
thread running on the CPU into memory, switch to a different execution
thread, and then later restore that old process.  We could write all
that in assembly, but luckily there are some handy unix functions that
do that kind of thing.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">getcontext</td>
<td class="left">gets the current state into a ucontext variable, which you can then modify</td>
</tr>

<tr>
<td class="left">makecontext</td>
<td class="left">modifies a context, making it include a function call of your choice</td>
</tr>

<tr>
<td class="left">swapcontext</td>
<td class="left">stores the current context in a variable, and switches execution to the given new context</td>
</tr>
</tbody>
</table>

<p>
Of course that's not very specific, so to get more information use the
man command line tool.
</p>

<pre class="example">
man getcontext
</pre>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> An Example</h2>
<div class="outline-text-2" id="text-3">
<p>
[<a href="example1.c">example1.c</a>]
</p>

<p>
To compile and run this code, use gcc
</p>

<pre class="example">
gcc example1.c -o example1
./example1
</pre>

<p>
You should see the parent and the child switch between each other.
</p>

<p>
You'll want to understand this code completely before continuing on.
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> What we want</h2>
<div class="outline-text-2" id="text-4">
<p>
You must implement all the functions outlined in
[<a href="basic_threads.h">basic_threads.h</a>].  For detailed descriptions of what each
function does, take a look at [<a href="basic_threads.c">basic_threads.c</a>].
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Compiling and running tests</h2>
<div class="outline-text-2" id="text-5">
<p>
The code you're writing is a library and doesn't have a main.
</p>

<p>
Compile this code like this to build the test application.
</p>

<pre class="example">
gcc tests.c CuTest.c basic_threads.c -o run_tests
</pre>

<p>
If you pass the test application an integer, it will only run tests
less than or equal the given test step (see "What to do" for the test
steps).
</p>

<p>
For example, this will run test steps 1 &amp; 2:
</p>

<pre class="example">
./run_tests 2
</pre>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> What to do</h2>
<div class="outline-text-2" id="text-6">
<p>
This code is arranged as a series of tests that step you through the
required functionality one stage at a time.
</p>

<p>
As you start each test set, take look at what you're trying to make
pass.
</p>
</div>

<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> Test 1: Just one thread</h3>
<div class="outline-text-3" id="text-6-1">
<p>
This should be a matter of just copying and pasting the various parts
of [<a href="example1.c">example1.c</a>] into the appropriate functions of
[<a href="basic_threads.c">basic_threads.c</a>] with a few modifications.  Feel free to add the
parent and child variables from example1 for the time being - in Test
2 we'll replace them with references to the threads array but let's
not get overly complicated.
</p>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> Test 2: A Bunch of Threads</h3>
<div class="outline-text-3" id="text-6-2">
<p>
This is a bigger change so get Test 1 passing before you start.
</p>

<p>
The basic idea is that you're going to have an array of ucontext_t
variables and as new threads get created you'll slot them into the
array.  Then your schedule_threads() will switch between all the
threads in that array.
</p>

<p>
A few wrinkles:
</p>

<ol class="org-ol">
<li>Just looking at the threads array by itself, it's going to be
impossible to tell if a particular position has a valid context or
just garbage data from the array's creation.  You'll probably want
an array of booleans that indicate if a particular slot is filled
with a valid context.

<p>
Of course, that array of booleans must be initialized itself!
</p>
</li>

<li>When you yield, it's important to know what the index of the
currently running thread is so that you can replace the correct
context in the threads array when you swap.  That's usually stored
in a global.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> Test 3: Reclaiming finished threads's slots</h3>
<div class="outline-text-3" id="text-6-3">
<p>
This test case may work automatically for you, depending on how you
implemented your Test 2.  
</p>

<p>
There are basically 2 ideas here:
</p>
<ol class="org-ol">
<li>One thread should be able to create new threads.
</li>
<li>When a particular thread completes, its slot in the threads array
becomes available again and is reused.  Thus although we might be
only able to support 5 threads at the same time, we can have more
threads over the lifetime of the program.
</li>
</ol>

<p>
Note that we're still not going to worry about freeing what we
malloced (yet) just the slot in the threads array.
</p>
</div>
</div>

<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> Test 4: Thread parameters</h3>
<div class="outline-text-3" id="text-6-4">
</div><div id="outline-container-sec-6-4-1" class="outline-4">
<h4 id="sec-6-4-1"><span class="section-number-4">6.4.1</span> Parameters?</h4>
<div class="outline-text-4" id="text-6-4-1">
<p>
Right now all the functions we're threading take no parameters.  This
is very unusual - most of the time thread functions need parameters
because we often want to start the same function in parallel multiple
times with different parameters (e.g. pull the data from several
datafiles in the same way, but each datafile happen in its own
thread).  But because of C's type checking, this is diffcult because
each of these functions would have a different function pointer type.
We don't want several versions of create new thread one of which takes
integer parameters:
</p>

<pre class="example">
void create_new_thread(void (*fun_ptr)(int)) {
</pre>

<p>
and one which takes two strings
</p>

<pre class="example">
void create_new_thread(void (*fun_ptr)(char*, char*)) {
</pre>

<p>
etc.
</p>

<p>
The solution to this problem will be C void pointers (look them up if
you don't recall what they are).
</p>

<p>
All our parameterized thread functions will take one parameter, a void
pointer that can point to any kind of data.  In cases where we'd like
multiple parameters, we'll pass a void pointer to a struct.  Then the
function can cast that pointer to whatever pointer kind it needs.
</p>

<p>
Take a look at the test cases to see how this is used.
</p>

<p>
<b>Note:</b>
</p>

<p>
When passing parameters to threads like this, we are going to have to
sure that the memory location we are passing is actually going to
still be allocated at the time the data is used.
</p>

<p>
For example, this is a subtle memory corruption bug (if you don't see
it, get some help so you do understand):
</p>

<div class="org-src-container">

<pre class="src src-C">void runs_as_thread()
{
    int value;
    create_new_parameterized_thread(other_function, &amp;value);
    finish_thread();
}
</pre>
</div>

<p>
Programming in C is all about cultivating an appropriate amount of
paranoia.
</p>

<p>
To solve this problem, the correct thing to do would be to implement
join.
</p>

<div class="org-src-container">

<pre class="src src-C">void runs_as_thread()
{
    int value;
    thread_id result = create_new_parameterized_thread(other_function, &amp;value);
    join_thread(result);
    finish_thread();
}
</pre>
</div>

<p>
&#x2026;that would be totally doable, but we're not going to go through the
trouble in this assignment.
</p>
</div>
</div>
<div id="outline-container-sec-6-4-2" class="outline-4">
<h4 id="sec-6-4-2"><span class="section-number-4">6.4.2</span> How to do this</h4>
<div class="outline-text-4" id="text-6-4-2">
<p>
Take a look at the manpage for makecontext.  You'll see that you can
pass an arbitrary number of parameters to the makecontext function (in
that way, it is similar to C's printf).  Just be sure the 3rd argument
is the number of extra parameters you want to pass (1 in this case).
</p>

<p>
The code otherwise will be exactly like create_new_thread.
</p>

<p>
A few minor wrinkles:
</p>

<ol class="org-ol">
<li>The function parameter to makecontext is still specified as "void
(*)()" (that is, a pointer to a function that takes no parameters
and returns nothing).  That's because there's no way to say "a
pointer to a function that takes an arbitrary number of parameters
and returns nothing".  So to make this work we'll have to cast our
function parameter to that type:

<pre class="example">
void(*cast_ptr)() = (void(*)()) fun_ptr;
</pre>
</li>

<li>It should irk you that create_new_thread and
create_new_parameterized_thread have basically the same code.  Will
we allow this code duplication? Hell no!  Turns out fixing this is
easy though - we can just make create_new_thread call
create_new_parameterized_thread with a null parameter.  Think for a
second: why is this safe? 

<p>
Be sure you do this - as always, we will deduct points from your
assignment for egregiously duplicated code.
</p>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> Test 5: Removing the need for finish_thread</h3>
<div class="outline-text-3" id="text-6-5">
<p>
If you've experimented with writing your own test thread functions,
you may have noticed how super-bad news it is if you write a threaded
function that doesn't call finish_thread when it returns.  Your
program instantly and errorlessly terminates, and even judicious use
of a debugger can't identify the problem (because this is considered a
"natural" exit, not an error).
</p>

<p>
If you haven't seen this, try running Test 5 without implementing any
code so you see what that looks like.
</p>

<p>
We could make the error more obvious, but rather than that it would be
better if the thread function returning just called finish_thread
implicitly.  The way to do this is adding a new helper function that
makecontext calls (instead of the actual thread function).  This
function will take 2 parameters, the actual thread function pointer
and the void pointer parameter to pass it.
</p>

<p>
Then the helper function will call the actual thread function, and
once it returns, call finish_thread.  If we wanted to, we could also
add some initialization that occurs before the function call - not
needed quite yet, but it will be quite handy once we have preemption
in a future assignment.
</p>
</div>
</div>

<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6"><span class="section-number-3">6.6</span> Test 6: Freeing what we have malloced</h3>
<div class="outline-text-3" id="text-6-6">
<p>
Your first instinct might be that that helper function we implemented
in the previous step would be a great place to call free to free the
thread stack allocation.  This is a terrible idea!  (stop for a second
and see if you can figure out why it is a terrible idea without
reading my solution)
</p>
</div>

<div id="outline-container-sec-6-6-1" class="outline-4">
<h4 id="sec-6-6-1"><span class="section-number-4">6.6.1</span> Why it's a terrible idea</h4>
<div class="outline-text-4" id="text-6-6-1">
<p>
The memory we have malloced is the stack of the thread.  The stack of
the thread that is currently running your helper function.  If we free
it, any following code (i.e. that code that executes the context
switch to the scheduler) will be running in a freed stack.
</p>

<p>
This is particularly bad news because most of the time this code will
probably work, because the stack remains in use for such a short time
the OS will probably not repurpose its page.  But then 1 out of 1000
runs, you'll spontaneously get a segmentation fault - good luck
tracking that down.
</p>

<p>
Remember - an appropriate amount of paranoia is what is necessary.
</p>
</div>
</div>

<div id="outline-container-sec-6-6-2" class="outline-4">
<h4 id="sec-6-6-2"><span class="section-number-4">6.6.2</span> How to fix it</h4>
<div class="outline-text-4" id="text-6-6-2">
<p>
The free cannot happen while we are running the thread.  So the
scheduler must be the place to execute the free.  We need to signal
scheduler that this is what it should do (maybe by marking the thread
invalid, or some sort of magic global you setup).
</p>
</div>
</div>

<div id="outline-container-sec-6-6-3" class="outline-4">
<h4 id="sec-6-6-3"><span class="section-number-4">6.6.3</span> Testing this</h4>
<div class="outline-text-4" id="text-6-6-3">
<p>
We can't write an ordinary test for this but what we can do is use
valgrind (a C memory safety checker).  It's pretty easy to use, here's
how to run it (if this doesn't work you may have to install valgrind):
</p>

<pre class="example">
valgrind ./run_tests 6
</pre>
</div>

<ol class="org-ol"><li><a id="sec-6-6-3-1" name="sec-6-6-3-1"></a>What a successful output looks like<br  /><div class="outline-text-5" id="text-6-6-3-1">
<pre class="example">
   valgrind ./run_tests 6                                    
==17524== Memcheck, a memory error detector
==17524== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==17524== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==17524== Command: ./memtry 6
==17524== 
==17524== Warning: client switching stacks?  SP change: 0x1ffefffc78 --&gt; 0x5202818
==17524==          to suppress, use: --max-stackframe=137336181856 or greater
==17524== Warning: client switching stacks?  SP change: 0x52027c8 --&gt; 0x1ffefffc80
==17524==          to suppress, use: --max-stackframe=137336181944 or greater
==17524== Warning: client switching stacks?  SP change: 0x1ffefffc78 --&gt; 0x5212858
==17524==          to suppress, use: --max-stackframe=137336116256 or greater
==17524==          further instances of this message will not be shown.
........

OK (8 tests)

==17524== 
==17524== HEAP SUMMARY:
==17524==     in use at exit: 0 bytes in 0 blocks
==17524==   total heap usage: 54 allocs, 54 frees, 2,238,125 bytes allocated
==17524== 
==17524== All heap blocks were freed -- no leaks are possible
==17524== 
==17524== For counts of detected and suppressed errors, rerun with: -v
==17524== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</pre>

<p>
Warning indicating we're switching stacks is find - because we are
switching stacks in this code.
</p>
</div>
</li>

<li><a id="sec-6-6-3-2" name="sec-6-6-3-2"></a>What a memory leak looks like<br  /><div class="outline-text-5" id="text-6-6-3-2">
<p>
If you aren't freeing what you malloced, it should look something like this
</p>

<pre class="example">
   valgrind ./memtry 6                                           
==17632== Memcheck, a memory error detector
==17632== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==17632== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==17632== Command: ./memtry 6
==17632== 
doing a malloc
doing a malloc
==17632== Warning: client switching stacks?  SP change: 0x1ffefffc78 --&gt; 0x5202c58
==17632==          to suppress, use: --max-stackframe=137336180768 or greater
==17632== Warning: client switching stacks?  SP change: 0x5202c08 --&gt; 0x1ffefffc80
==17632==          to suppress, use: --max-stackframe=137336180856 or greater
==17632== Warning: client switching stacks?  SP change: 0x1ffefffc78 --&gt; 0x5212c98
==17632==          to suppress, use: --max-stackframe=137336115168 or greater
==17632==          further instances of this message will not be shown.
........

OK (8 tests)

==17632== 
==17632== HEAP SUMMARY:
==17632==     in use at exit: 2,228,224 bytes in 34 blocks
==17632==   total heap usage: 54 allocs, 20 frees, 2,238,125 bytes allocated
==17632== 
==17632== LEAK SUMMARY:
==17632==    definitely lost: 1,835,008 bytes in 28 blocks
==17632==    indirectly lost: 65,536 bytes in 1 blocks
==17632==      possibly lost: 131,072 bytes in 2 blocks
==17632==    still reachable: 196,608 bytes in 3 blocks
==17632==         suppressed: 0 bytes in 0 blocks
==17632== Rerun with --leak-check=full to see details of leaked memory
==17632== 
==17632== For counts of detected and suppressed errors, rerun with: -v
==17632== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</pre>

<p>
Leaked over a megabyte in 8 tests&#x2026;not ideal.
</p>
</div>
</li>

<li><a id="sec-6-6-3-3" name="sec-6-6-3-3"></a>What an access of illegal (freed) memory looks like<br  /><div class="outline-text-5" id="text-6-6-3-3">
<p>
In this example I unsafely free memory in my finish thread function.
</p>

<pre class="example">
   valgrind ./memtry 6                                           
==17746== Memcheck, a memory error detector
==17746== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==17746== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==17746== Command: ./memtry 6
==17746== 
==17746== Warning: client switching stacks?  SP change: 0x1ffefffc78 --&gt; 0x5202818
==17746==          to suppress, use: --max-stackframe=137336181856 or greater
==17746== Warning: client switching stacks?  SP change: 0x52027c8 --&gt; 0x1ffefffc80
==17746==          to suppress, use: --max-stackframe=137336181944 or greater
==17746== Warning: client switching stacks?  SP change: 0x1ffefffc78 --&gt; 0x5212858
==17746==          to suppress, use: --max-stackframe=137336116256 or greater
==17746==          further instances of this message will not be shown.
==17746== Invalid write of size 8
==17746==    at 0x4C2E10B: free (vg_replace_malloc.c:530)
==17746==    by 0x10901D: finish_thread (in /home/hewner/Private/play/threading/memtry)
==17746==    by 0x108D75: thread_run_helper (in /home/hewner/Private/play/threading/memtry)
==17746==    by 0x4E8307F: ??? (in /usr/lib/libc-2.26.so)
==17746==  Address 0x52027a8 is 65,400 bytes inside a block of size 65,536 free'd
==17746==    at 0x4C2E10B: free (vg_replace_malloc.c:530)
==17746==    by 0x10901D: finish_thread (in /home/hewner/Private/play/threading/memtry)
==17746==    by 0x108D75: thread_run_helper (in /home/hewner/Private/play/threading/memtry)
==17746==    by 0x4E8307F: ??? (in /usr/lib/libc-2.26.so)
==17746==  Block was alloc'd at
==17746==    at 0x4C2CEDF: malloc (vg_replace_malloc.c:299)
==17746==    by 0x108E52: create_new_parameterized_thread (in /home/hewner/Private/play/threading/memtry)
==17746==    by 0x108D95: create_new_thread (in /home/hewner/Private/play/threading/memtry)
==17746==    by 0x10960C: test_5 (in /home/hewner/Private/play/threading/memtry)
==17746==    by 0x109DFB: CuTestRun (in /home/hewner/Private/play/threading/memtry)
==17746==    by 0x10A53B: CuSuiteRun (in /home/hewner/Private/play/threading/memtry)
==17746==    by 0x109828: main (in /home/hewner/Private/play/threading/memtry)
==17746== 

***MANY MANY MORE ERRORS OMITTED HERE***

........

OK (8 tests)

==17746== 
==17746== HEAP SUMMARY:
==17746==     in use at exit: 0 bytes in 0 blocks
==17746==   total heap usage: 54 allocs, 54 frees, 2,238,125 bytes allocated
==17746== 
==17746== All heap blocks were freed -- no leaks are possible
==17746== 
==17746== For counts of detected and suppressed errors, rerun with: -v
==17746== ERROR SUMMARY: 136 errors from 36 contexts (suppressed: 0 from 0)
</pre>

<p>
As you can see, although the tests seem to run fine I've actually made
many illegal accesses here.
</p>
</div>
</li></ol>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Conclusion</h2>
<div class="outline-text-2" id="text-7">
<p>
Submit your assignment by committing your changed (source) files to the git repo.
</p>

<pre class="example">
git commit -am "assignment finished"
git push
</pre>

<p>
Be sure to check git status after you're done to ensure everything is as it should be.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Buffalo</p>
<p class="date">Created: 2018-03-06 Tue 11:08</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
